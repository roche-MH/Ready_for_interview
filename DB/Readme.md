# DataBase

* 데이터베이스
  * 데이터베이스를 사용하는 이유
  * 데이터베이스 시스템 등장
  * 데이터베이스의 장점
  * 데이터베이스의 단점
  * 데이터베이스의 특징
* Schema
  * 스키마란?
  * 스키마 특징
  * 스키마 3계층
* Index
  * 인덱스란?
  * Index의 자료구조
  * Primary index vs Secondary index
  * Composite index
  * Index 의 성능과 고려해야할 사항



## 데이터베이스

어느 한 조직에서 업무 처리를 위해 다수의 응용시스템 혹은 다수의 사용자들이 공용으로 사용하기 위해 저장된 운영 데이터의 집합



**데이터베이스를 사용하는 이유**

1. 파일처리에서 데이터베이스로의 시스템 전환

![image-20200805205506745](https://t1.daumcdn.net/cfile/tistory/233E9340543E16CE30)

> 파일처리 시스템

![image-20200805205559854](https://t1.daumcdn.net/cfile/tistory/2136103E543E16DC1E)

* 파일처리 시스템의 문제점
  * 중복: 파일처리시스템은 각 파일마다 필요한 데이터를 각각 가지고 있어야 함으로 전체적인 시간과 노력, 경제비용에 있어서 효율이 없다.
  * 비일관성: 데이터에 변경사항이 조금만 있어도 각 파일에서 해당되는 데이터를 모두 변경해야 함으로 수정에 문제가 있고, 한꺼번에 수정이 되지 않으면 데이터 값이 서로 틀리게 되는 문제점이 있다.
  * 응용 프로그램 개발 문제 : 기존의 파일 시스템은 파일 용도에만 맞춰서 제작되기 때문에 다른 프로그램을 만들때는 다시 데이터베이스 작업을 해야 한다는 문제가 있다.
  * 데이터 추가 및 검색의 문제: 데이터가 여러 파일에 산재하고 또 그 파일마다 데이터베이스 양식이 다르기 때문에 일률적인 검색이나 단순 추가 작업이 어렵다.



**데이터베이스 시스템 등장**

* 등장목적 : 파일처리 시스템의 문제점을 해결하기 위함
* 데이터 베이스 시스템 : 어떤 업무에 필요한 다양한 형태의 데이터를 모아 놓은 데이터의 집합체
* 데이터베이스 관리 시스템: 모든 응용프로그램들이 데이터베이스를 공유할수 있도록 관리해 주는 소프트웨어(ex: 오라클, SQL, DB2, Mysql, MongoDB,MariaDB ..etc)
* 데이터베이스의 구성요소(데이터베이스, DBMS, 데이터 언어, 데이터베이스 관리자, 일반 사용자)



**데이터베이스의 장점**

* 데이터의 중복을 피할수 있다.

* 저장된 자료를 공동으로 이용할수 있다.
* 데이터의 일관성과 무결성을 유지할수 있다.
* 데이터의 논리적, 물리적 독립성이 보장된다.
* 보안을 유지할수 있다.
* 데이터를 표준화 할수 있다.
* 데이터를 통합하여 관리할 수 있다.
* 항상 최신의 데이터 유지가 가능하다.

* 데이터의 실시간 처리가 가능하다.



**데이터베이스 단점**

* 데이터베이스 전문가가 부족하다
* 전산화 비용이 증가한다
* 대용량 디스크로의 집중적인 Access로 Overhead 가 발생한다.
* 파일의 백업과 회복이 어렵다



**데이터 베이스의 특성**

* 실시간 접근성 : 수시적이고 비정형적인 질의(조회)에 대해 실시간 처리 응답이 가능해야 한다.
* 계속적인 변화 : 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다.
* 동시공용 : 여러 사용자가 동시에 자기가 원하는 데이터를 이용할수 있어야한다.
* 내용에 의한 참조 : 데이터 베이스에 있는 데이터를 참조할때 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 내용으로 데이터를 찾는다.



## Schema

**스키마란?**

* 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
* 스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작시 데이터 값들이 갖는 제약 조건등에 관해 전반적으로 정의한다.
* 스키마는 사용자의 관점에 따라 외부스키마, 개념스키마, 내부스키마로 나뉜다.

![image-20200805212716043](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F9936823A5B698C4023F849)

**스키마 특징**

* 스키마는 데이터 사전(Data Dictionary)에 저장되며, 다른 이름으로 메타데이터라고도 한다.
* 스키마는 현실세계의 특정한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다.
* 스키마는 시간에 따라 불변인 특성을 갖는다.
* 스키마는 데이터의 구조적 특성을 의미하며, 인스턴스에 의해 규정된다.



**스키마의 3계층**

데이터베이스 관리 시스템은 외부적 스키마에 따라 명시된 사용자의 요구를 개념적 스키마에 적합한 형태로 변경하고 이를 다시 내부적 스키마에 적합한 형태로 변환한다.



1. 외부스키마 = 사용자 뷰
   * 외부스키마는 사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것이다.
   * 외부스키마는 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Sub Schema) 라고도 한다.
   * 하나의 데이터베이스 시스템에는 여러개의 외부 스키마가 존재할 수 있으며 하나의 외부 스키마를 여러개의 응용 프로그램이나 사용자가 공용할 수도 있다.
   * 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할수 있도록 허용한다.
   * 일반 사용자의 질의어(SQL)을 이용하여 DB를 쉽게 사용할수 있다.
   * 응용 프로그래머는 C, JAVA 등의 언어를 사용하여 DB 에 접근한다.
2. 개념스키마 = 전체적인 뷰
   * 개념 스키마는 데이터베이스의 전체적인 논리적 구조로서, 모든 응용프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다.
   * 개념스키마는 개체간의 관계와 제약조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다.
   * 데이터베이스 파일에 저장되는 데이터의 형태를 나타내는 것으로, 단순히 스키마(Schema)라고 하면 개념 스키마를 의미한다.
   * 기관이나 조직체의 관점에서 데이터베이스를 정의한것이다.
   * 데이터베이스 관리자(DBA)에 의해서 구성된다.
3. 내부 스키마 = 저장스키마
   * 내부 스키마는 물리적 저장장치의 입장에서 본 데이터베이스 구조로, 물리적인 저장장치와 밀접한 계층이다.
   * 내부스키마는 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장데이터 항목의 표현방법, 내부 레코드의 물리적 순서등을 나타낸다.
   * 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마이다.



## Index

**인덱스란?**

인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할수 있다.

이 비유를 그대로 가져와서 인덱스를 살펴본다면 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 된다.

DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 준다.

DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정 하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올수 있다.

> 인덱스를 많이 생성하면 인덱스 테이블이라는 테이블이 많이 생성됨으로 메모리를 많이 소비하게 된다.
>
> 따라서 PK 같은 컬럼들을 인덱싱 하도록 하고, 많은 컬럼에 남용하지 않는것이 좋다.



**Index 자료구조**

1. B-Tree 인덱스 알고리즘

* 일반적으로 사용되는 인덱스 알고리즘은 B-Tree알고리즘이다. B-Tree 인덱스는 컬럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리함) 원래의 값을 이용해 인덱싱하는 알고리즘

2. Hash 인덱스 알고리즘

* 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매운 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 할때는 해시 인덱스를 사용할수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

3. 풀 텍스트 인덱스 알고리즘

* 문서의 내용 전체를 인덱스화 해서 특정 키워드가 포함된 문서를 검색하는 풀텍스트 인덱스는 InnoDB 나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도 B-Tree 인덱스를 사용할수 없어서 대안된 방식

4. R-Tree 인덱스

* 기본적인 내부 메커니즘은 B-Tree 와 흡사하며 , B-Tree의 인덱스를 구성하는 컬럼의 값이 1차원 스칼라 값이라면  R-Tree 의 인덱스는 2차원 공간 개념의 값이다
* GPS 나 지도 서비스 같은 위치 기반의 서비스 구현시 필요한 MySQL 공간확장을 이용할때 사용한다.

**Hash table 보다 b-tree를 자주 사용하는 이유**

SELECT 질의 조건에는 부등호(<>)연산도 포함되는데 Hash table을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 

hashtable 은 동등 연산(=)에 특화되어있기 때문에 데이터베이스의 자료구조로 적합하지 않다고 한다.



**Primary Index VS Secondary Index**

클러스터란 여러개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않다. 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.



클러스터드 인덱스는 테이블의 PK 에 대해서만 적용되는 내용이다. 즉 PK 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다.

클러스터드 인덱스에서 PK 값에 의해 레코드의 저장위치가 결정되며 PK 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다. 그렇기 때문에 PK 를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.



클러스터드 인덱스는 테이블당 한개만 생성할수 있다. PK 값에서만 적용되기 때문이다. 하지만 Non 클러스터드 인덱스는 테이블당 여러개를 생성할수 있다.



**Composite Index**

인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title을 검색하는 경우, index 를 생성한 효과를 볼수 있지만, author 만으로 검색하는 경우 index를 생성한 것이 소용이 없어진다. 

따라서 SELECT 질의를 어떻게 할것인가, 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.



**Index의 성능과 고려해야할 사항**

INDEX는 많은면 많을수록 좋지 않다.

* Index를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할때 별도의 과정이 추가적으로 발생한다. 

* INSERT의 경우 INDEX에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다. 

* DELETE의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게된다. 이경우 row의 수는 그대로 남게되는거고 이게 반복되면 100개 행에서 실제데이터는 10개가 있을수도 있다.

* UPDATE의 경우 INSERT와 DELETE의 문제점을 동시에 가진다.

  이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문이고 변경전 데이터는 삭제되지 않고 INSERT로 인한 split 도 발생하게 된다.

* 하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠수도 있다는 것이다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재한다는 것이다.

* `이름`,`나이`,`성별` 세가지의 필드를 갖고 있는 테이블의 경우 이름은 온갖 경우의 수가 존재하고 나이는 INT 타입을 갖고, 성별은 남,여 두가지 경우에 대해서만 데이터가 존재할것이다. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적인가 라고 한다면 이름에 대해서만 인덱스를 생성하는 것이 효율적이다.

* 성별이나 나이에 인덱스를 생성했을 경우, 10000레코드에 해당하는 테이블에 대해서 2000단위로 성별에 인덱스를 생성했다고 가정한다면 값의 range가 적은 성별은 인덱스를 읽고 다시한번 디스크 I/O가 발생하기 때문에 비효율 적이게 된다.



