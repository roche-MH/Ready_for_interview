# etc

* 포인터

  * 메모리 상의 주소를 저장하는 공간

* 객체지향 프로그래밍과의 장점

  * 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방식으로 `추상화`가 쉽고 상속을 통해 코드`재생산성`을 높일수 있으며 객체 단위 코드가 나눠져 있기 때문에 `디버깅과 유지보수`에 용이

* 객체지향 프로그래밍의 특징

  * `추상화`: 필요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
  * `캡슐화`: 속성과 기능을 정의하는 멤버 변수와 메소드를 클래스라는 캡슐에 넣는 것
  * `상속`: 부모 클래스의 속성과 기능을 그대로 이어 받아 사용할수 있게 하고 기능의 일부분을 변경해야 할 경우, 상속 받은 자식 클래스에서 해당 기능만 다시 수정(정의)하여 사용할수 있게 하는것
  * `다형성`: 하나의 변수명, 함수명 등이 상황에 따라서 다른 의미로 해석될수 있는것

* 다형성의 구체 사례

  * 부모 타입으로 자식 객체를 참조하여 부모 타입에 대한 메소드들을 쓸수 있음
  * 부모 타입으로 자식 타입의 객체를 참조할 때는 묵시적으로 형변환, 부모 타입의 객체를 자식 타입으로 참조하게 할때는 명시적으로 형변환 할수 있고 그 객체가 원래 자식 객체였는지 부모 객체 였는지에 따라 사용 가능한 필드나 메소드가 정해짐

* 객체지향 설계의 5원칙

  * `SRP(Single Responsibility Principle)` : 단일 책임 원칙, 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단하나의 이유이어야 한다.
  * `OCP(Open-Closed Principle)`:  개방-폐쇄 원칙, 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  * `LSP(Liskov Substitution Principle)`: 인터페이스 분리 원칙, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  * `DIP(Dependency Inversion Principle)` : 의존 역전 원칙, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

* 클래스와 인스턴스의 차이

  * 클래스는 객체를 만들기 위한 템플릿, 객체는 클래스라는 템플릿을 토대로 `메모리에 할당한 실체`

* Immutable

  * 생성 후 변경 불가한 객체로 변경을 하려면 복사 이후 변경해야함

* Call by Value vs Call by Reference

  * Call by Value 와 Call by Reference 는 **값을 복사하여 처리하느냐, 아니면 직접 참조하느냐 차이** `Call by value` 는 인자로 받은 값을 복사하여 처리하고 `Call by reference` 는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 줌

* 컴파일 언어 와 스크립트 언어의 차이

  * `컴파일 언어` 는 컴파일러를 통해 사전에 컴파일 되어 기계어 상태로 실행되고 `스크립트 언어`는 컴파일 단계없이 인터프리터에 의해 실행 단계에서 한줄씩 기계어로 변역하여 실행
  * 일반적으로 컴파일언어가 스크립트 언어에 비해 빠르고 안정적이다
  * 컴파일 언어는 오류 찾기가 쉽고 , 스크립트 언어는 한줄씩 실행되어 오류 찾기가 힘들다

* 동기식과 비동기식의 차이

  * 동기식은 요청에 대한 응답을 기다린후 `응답이 오면 실행` 하는 방식이고 비동기식은 요청에 대한 `응답을 기다리지 않고 실행` 하는 방식
  * 동기식은 구성이 단순하나 멀티태스킹이 불가능하고 비동기식은 멀티태스킹이 가능하나 요청량이 많아질 경우 부하 컨트롤 과 데이터의 일관성 유지등 추가적인 처리가 필요하다

* 블락킹과 논블락킹의 차이

  * 블락킹은 I/O 처리 함수가 끝날 때까지 기다리고 처리가 끝나면 결과를 리턴하는 방식이고 논블락킹은 I/O 처리 함수가 끝나지 않더라도 기다리지 않고 다른 작업을 처리하는 방식

* 블락킹과 비동기의 차이

  * 블락킹과 비동기 모두 응답을 기다리지 않는 공통점이 있지만, 재실행 시점이 비동기는 `요청에 대한 응답` 이라는 관점이고 블락킹은 `I/O처리(시스템 함수 호출의 리턴)` 이라는 관점에서 다르다

* RESTful API

  * `REST` 는 `HTTP, WWW에서 웹에 존재하는 모든 자원에 고유한 URI를 부여해 활용하는것`으로 , 자원을 저으이하고 자원에 대한 주소를 지정하는 방법론
  * `RESTful API` 는 `REST 기반의 규칙들을 지켜서 설계된 API`
  * 기본 설계 원칙
    * `/`를 계층 관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
    
    * 자원에 대한 정보는 명사로 표현하고 자원에 대한 `행위는 HTTP 메소드`로 표현
    
    * 소문자와 `-`를 사용
    
    * 브라우저는 form-data 형식의 submit으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 둘다 form-data 형식으로 보내든 하나로 통일
    
    * 파일 확장자는 URL에 포함시키지 않는다.
    
      ```python
      http://restapi.example.com/members/soccer/345/photo.jpg (X)
          
      #REST API 에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URL 안에 포함시키지 않는다. Accept header를 사용한다.
      GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg
      ```
    
      

* Rest 구성

  * 자원(Resource) - url
  * 행위(Verb) - HTTP METHOD
  * 표현(Representations)

* Rest 의 특징

  * Uniform(유니폼 인터페이스)
    * URL로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일
  * Stateless(무상태성)
    * REST 는 무상태성 성격을 갖는다. 작업을 위한 상태정보를 따로 저장하고 관리하지 않는다. **세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 된다.** 때문에 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해진다.
  * Cacheable(캐시가능)
    * Rest의 가장 큰 특징중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다. 따라서 HTTP가 가진 캐싱 기능이 적용가능하다. HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag 를 이용하면 캐싱구현이 가능하다.
  * Self-descriptiveness(자체 표현 구조)
    * REST의 또 다른 큰 특징중 하나는 REST API 메세지만 보고도 이를 쉽게 이해할수 있는 자체 표현 구조로 되어 있다.
  * Client - Server 구조
    * Rest 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션,로그인 정보) 등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 된다.
  * 계층형 구조
    * REST 서버는 다중 계층으로 구성될수 있으며 보안, 로드 밸런싱, 암호화계층을 추가해 구조상의 유현성을 둘수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할수 있게 한다.

* REST API 중심 규칙

  * URL는 정보의 자원을 표현해야 한다(리소스명은 동사보다는 명사를 사용)

    ```python
    GET /members/delete/1
    # 이방식은 REST를 제대로 적용하지 않은 URL 이다.
    # URL은 자원을 표현하는데 중점을 두어야 한다. delete와 같은 행위에 대한 표현이 들어가서는 안된다.
    ```

  * 자원에 대한 행위는 HTTP Method(GET,POST,PUT, DELETE 등)로 표현

    ```python
    DELETE /members/1
    # 위 잘못된 URL를 HTTP Method를 통해 수정해보면 이렇게 수정할수 있다.
    ```

  * 회원정보를 가져올때는 GET, 회원 추가시의 행위를 표현하고자 할때는 POST METHOD를 사용하여 표현한다.

    ```python
    #회원정보 가져오는 URL
    GET /members/1
    #회원을 추가할때
    POST /members/2
    #유저 삭제
    delete /members/1
    #다중 유저삭제
    HTTP PATCH /members/drop?id=1,2,3,4,5,10
    ```

* HTTP METHOD의 알맞은 역할

  * | METHOD  | 역할                                                         |
    | ------- | ------------------------------------------------------------ |
    | POST    | POST를 통해 해당 URL를 요청하면 리소스를 생성한다.           |
    | GET     | GET를 통해 해당 리소스를 조회한다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다. |
    | PUT     | PUT를 통해 해당 리소스를 수정한다.(자원의 전체 교체, 자원내 모든 필드 필요) |
    | DELETE  | DELETE를 통해 리소스를 삭제한다.                             |
    | HEAD    | 웹서버의 다운여부 점검(Health check) 이나 웹서버 정보(버전 등)을 얻기위해 사용 |
    | TRACE   | 원격지 서버에 Loopback 메시지를 호출하기 위해 사용(이전까지 요청한 정보들을 목록으로 요청) |
    | CONNECT | 웹서버에 프록시 기능을 요청할때 사용                         |
    | PATCH   | PATCH를 통해 해당 리소스를 수정한다. (자원의 일부분교체)     |

* RESTful API 장단점

  * HTTP를 사용하므로 웹 인프라를 그대로 이용할수 있고 MSA에 적합하여 재사용에서 이점이 존재
  * HTTP를 사용하므로 HTTP 통신 모델에 제약적

* HTTP 응답 상태 코드

  | 상태코드 | 내용                                                         |
  | -------- | ------------------------------------------------------------ |
  | 200      | 클라이언트의 요청을 정상적으로 수행함                        |
  | 201      | 클라이언트가 어떤한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨(POST를 통한 리소스 생성 작업시) |
  | 400      | 클라이언트의 요청이 부적절 한 경우 사용하는 응답코드         |
  | 401      | 클라이언트가 인증되지 않은 상태에서 보호된 리소스를 요청했을때 사용하는 응답코드 <br /> (로그인 하지 않은 유저가 로그인했을때, 요청 가능한 리소스를 요청했을때) |
  | 403      | 유저 인증상태와 관계없이 응답하고 싶지 않은 리소스를 클라리언트가 요청했을때 사용하는 응답코드 <br /> (403 보다는 400이나 404를 사용할 것을 권고, 403 자체가 리소스가 존재한다는 뜻이기 때문에) |
  | 405      | 클라이언트가 요청한 리소스에서는 사용 불가능한 Method를 이용했을 경우 사용하는 응답 코드 |
  | 301      | 클라이언트가 요청한 리소스에 대한 URL가 변경되었을때 사용하는 응답코드<br />(응답시 Location header 에 변경된 URL를 적어줘야 한다) |
  | 500      | 서버에 문제가 있을경우 사용하는 응답코드                     |



**GraphQL**

GraphQL 은 Structed Query Language(SQL) 와 마찬가지로 쿼리 언어이다. 하지만 gql과 sql의 언어적 구조 차이는 매우크다. 또한 gql과 sql이 실전에서 쓰이는 방식의 차이도 매우크다.

sql은 **데이터베이스 시스템**에 저장된 데이터를 효율적으로 가져오는것이 목적이고, gql은 **웹 클라이언트**가 데이터를 서버로 부터 효율적으로 가져오는것이 목적이다. sql의 문장은 주로 백엔드 시스템에서 작성하고 호출하는 반면, gql의 문장은 주로 클라이언트 시스템에서 작성하고 호출한다.

**sql 예시**

```python
SELECT plot_id, species_id, sex, weight, ROUND(weight / 1000.0, 2) FROM surveys;
```

**gql 예시**

```python
{
  hero {
    name
    friends {
      name
    }
  }
}
```

서버사이트 gql 어플리케이션은 gql로 작성된 쿼리를 입력받아 쿼리를 처리한 결과를 다시 클라이언트로 돌려준다. HTTP API 자체가 특정 데이터베이스나 플렛폼에 종속적이지 않은것처럼 마찬가지로 gql 역시 어떤 특정 데이터베이스나 플랫폼에 종속적이지 않는다. **심지어 네트워크 방식에도 종속적이지 않는다.**

일반적으로 gql의 인터페이스간 송수신은 네트워크 레이어 L7의 HTTP POST 메서드와 웹소켓 프로토콜을 활용한다. 필요에 따라서는 얼마든지 L4의 TCP/UDP를 활용하거나 심지어 L2형식의 이더넷 프레임을 활용할수도 있다.

![image-20201017181651997](http://tech.kakao.com/files/graphql-pipeline.png)

> GraphQL 파이프라인



**REST API와 비교**

REST API는 URL, METHOD등을 조합하기 때문에 다양한 Endpoint가 존재한다. 반면, gql은 단 하나의 Endpoint가 존재한다. 또한, gql API 에서는 불러오는 데이터의 종류를 쿼리조합을 통해서 결정한다. 예를 들어, REST API에서는 각 Endpoint마다 데이터베이스 SQL 쿼리가 달라지는 반면, gql API는 gql 스키마의 타입마다 데이터베이스 SQL 쿼리가 달라진다.

![image-20201017181907227](http://tech.kakao.com/files/graphql-stack.png)

> HTTP와 gql 의 기술스택 비교

![image-20201017182008234](http://tech.kakao.com/files/graphql-mobile-api.png)

위 그림처럼, gql API를 사용하면 여러번 네트워크 호출을 할 필요없이, 한번의 네트워크 호출로 처리할수 있다.

**REST 와 GQL 어느걸 사용해야하나**

REST 와 gql 모두 장단점을 가지고 있기 때문에 한가지만 사용하는것이 아니라 각 상황에 맞춰서 사용하는것이 좋다

GraphQL

서로 다른 모양의 다양한 요청들에 대해 응답할수 있어야 할때

대부분의 요청이 CRUD(Create-Read-Update-Delete)에 해당할때

RESTful

HTTP와 HTTPS에 의한 Caching 을 잘 사용하고 싶을때 File 전송 등 단순한 Text로 처리되지 않는 요청들이 있을때

요청의 구조가 정해져 있을때



* 디자인 패턴

  * 소프트웨어 코드 작성시에 생기는 `공통적인 문제를 해결하는데 도움이 되는 코드 패턴`

* 디자인 패턴중 싱글톤 패턴

  * 전체 프로그램에서 단 1개의 객체를 생성하고 공유하는 코드 패턴으로 한번의 객체 생성으로 재사용이 가능하기 때문에 메모리 낭비를 방지하고 객체가 전역성을 띄기 때문에 공유가 용이

* 디자인 패턴중 MVC 패턴

  * Model, View, Controller라고 하는 컴포넌트로 분리하여 `비지니스 처리 로직`과 사용자 `인터페이스 요소`를 분리시켜 서로 영향없이 개발하기 수월

* 디자인 패턴중 MVT 패턴

  * MVC 와 동일한 역할을 수행하며 MVC 에서 View를 Template, Controller 를 View 라고 표현 한다.

* 디자인 패턴중 팩터리 패턴

  * 팩토리 패턴은 클래스의 `인스턴스를 만드는 것을 서브클래스에서 결정하는 패턴` 으로 팩토리 메서드 패턴과 추상 팩토리 패턴으로 구체화됨
  * 팩토리 메서드 패턴: 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정
  * 추상 팩토리 패턴: 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성

* PostgresSQL 과 ElasticSearch의 차이점

  * PostgresSQL은 관계형 데이터베이스이고 ElasticSearch 는 검색 및 분석엔진으로 다르고 ES는 데이터 모델을 JSON으로 하고 있어 NoSQL 처러 사용할수 있음

* Redis의 데이터 휘발을 막기 위한 방법

  * `snapshot` 기능을 통해 디스크에 백업하거나 AOF(Append Of File) 기능을 통해 `명령 쿼리를 저장` 해두고 서버가 셧다운 되면 재실행

    > AOF는 명령이 실행될때 마다 기록되는 파일(입력/수정/삭제 명령, 조회명령은 기록되지 않음)
    >
    > RDB 특정 간격마다 메모리에 있는 레디스 데이터 전체를 디스크에 쓴다(특정 시점마다 백업을 받을때 사용)

* TDD

  * `테스트 코드를 작성 한 후 그것을 통과하는 실행 코드를 작성` 하는 cycle로 개발을 해가는 방법으로 디버깅이 쉬워지고 코드의 신뢰성이 높아짐

* DDD

  * 도메인이 중심이 되는 개발 방식, `소프트웨어의 연관된 부분들을 연결하여 계속해서 진화하는 새로운 모델을 만들어나가 복잡한 애플리케이션을 만드는것을 쉽게 해줌`  , **느슨한 결합도, 높은 응집도** 를 가지고 있음

* 크롬 탭은 프로세스인지 스레드인지

  * 크롬은 탭마다 PID를 가지고 있는 Process이며 각 Tab 마다 랜더링 정보나 기타 데이터를 따로 관리, 그로 인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는 장점이 존재

* 함수형 프로그래밍

  * 함수형 프로그래밍은  계산을 수학적 함수의 조합으로 생각하는 방식
  * 1급 객체와 데이터 불변성 그리고 고차함수, 합성함수, 순수함수와 같은 다양한 함수 개념으로 구성

* Git에서 merge 와 rebase의 차이

  * git merge 를 하면 브랜치를 브랜치의 커밋로그는 사라지고 `병합하는 커밋로그가 master에 head에 추가`
  * gir rebase를 하면 브랜치를 base로 master 를 `커밋을 재정렬하여 브랜치의 커밋 하나 하나가 master에 정리되어 추가`

* 클라우드로의 전환이 필수적인 이유

  * 비용이 낮음: 서버 장비를 구매하고 유지하는 비용이 장기적으로 봤을때 클라우드 시스템을 이용하는 비용보다 비쌈
  * 효율적인 인적자원 운영: 직접 방문해야 하는 On-premise에 반해 웹에서 100% 제어 및 모니터링이 가능하기 때문에 개발(혹은 설계) 인력과 공존이 가능
  * 안정성: 클라우드는 다양한 공간으로 분산하기 때문에, 분산된 모든 곳에 동시다발적으로 문제가 생기지 않는 한 장애가 발생하지 않음
  * 확장성 : 트래픽이 임계점에 도달하면 빠르게 서버를 확장할수있음

  > k8s autuscaling 기능을 설정해 두었을 경우 트래픽이 발생하면 clone 웹서버를 생성하여 트래픽을 효율적으로 처리할수 있도록 도와줌, 트래픽이 줄어들면 다시 웹서버 컨테이너를 없애서 디스크 관리또한 가능



# Python

* Generator와 사용시의 장점

  * `Iterator를 생성해주는 루틴`으로 `yield` 키워드를 통해서 만드는데, Generator는 한번에 모든 데이터를 메모리에 적재할 필요가 없어서 메모리 효율이 높고 계산 결과가 필요할때 수행되므로 수행 시간을 꼭 필요한 시간 까지 늦출수 있다

* Decorator와 사용시의 장점

  * 기존의 코드에 여러 가지 기능을 추가하는 파이썬 구문으로 데코레이터를 함수나 클래스로 정의하고 수행하고자 하는 함수에 `@` 키워드를 통해서 삽입하여 실행시켜 생산성을 극대화 할수 있음

  > @login_required 사용자가 로그인한 경우에 아래행 실행

* Python Garbage Collection 동작 방식

  * 각각의 객체마다 `regerence count`를 갖고 있고 몇 곳에서 객체를 참조하는지를 나타내는데 인터프리터가 계속 이를 확인하다가 이 count 가 0이 되는 경우 그 객체를 삭제

* GIL 과 GIL을 보완하는 방법

  * 파이썬은 하나의 스레드만이 인터프리터의 제어권을 가질수 있는 개념인 GIL(Global Interpreter Lock)은 멀티 코어 환경에서도 어느 시점에서나 1개의 스레드만 실행될수 있기 때문에 `threading` 이 아닌`multiprocessing` 모듈을 통해 스레드 단위가 아닌 프로세스 별로 인터프리터 락을 잡아 보완해야 한다.

* Duck Typing

  * 동적 타입을 가지는 프로그래밍 언어에서 많이 사용되는 개념으로, 객체의 실제 타입보다는 객체의 변수와 메소드가 그 객체의 적합성을 결정하는 것을 의미한다.



# Design

* 영화관 좌석 예매 프로그램을 만들려고 한다. 해당 좌석에 대해 어떤 자료구조를 사용할 것인가?
  * 영화관 좌석 예매 시 좌석에 대한 동시적인 접근이 이뤄지므로 동기화 처리가 이뤄진 자료구조를 사용해야한다.
  * 탐색 관점에 있어서는 Array 가 빠르다
* 은행에서 송금을 하는 과정이 3단계로 되어 있는데 3단계에서 오류가 났다. 어떻게 해야 하는다?
  * ACID의 A의 원칙에 따라 전체를 Rollback 해야한다.
* DB관점에서 제한된 리소스로 인해 트래픽의 요청이 많은것에 대해서 어려움을 겪고 있을때 해결할수 있는 방법은 무엇인가?
  * 커넥션 풀을 이용하거나 메모리 캐시 DB를 이용한다.
* 서버 인스턴스를 여러개 돌릴때 어떤 걸 고려해야 되나?
  * 공유 자원에 대한 쓰기가 있을 경우 동기화가 이뤄져야 한다.
* 다수의 서버에서 어떻게 로그를 모니터링 할 것인가?
  * 로그서버를 구축하여 한곳에서 로그를 관리하며 특정 문구에 대한 트리거를 생성한다.