# etc

* 포인터

  * 메모리 상의 주소를 저장하는 공간

* 객체지향 프로그래밍과의 장점

  * 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방식으로 `추상화`가 쉽고 상속을 통해 코드`재생산성`을 높일수 있으며 객체 단위 코드가 나눠져 있기 때문에 `디버깅과 유지보수`에 용이

* 객체지향 프로그래밍의 특징

  * `추상화`: 필요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
  * `캡슐화`: 속성과 기능을 정의하는 멤버 변수와 메소드를 클래스라는 캡슐에 넣는 것
  * `상속`: 부모 클래스의 속성과 기능을 그대로 이어 받아 사용할수 있게 하고 기능의 일부분을 변경해야 할 경우, 상속 받은 자식 클래스에서 해당 기능만 다시 수정(정의)하여 사용할수 있게 하는것
  * `다형성`: 하나의 변수명, 함수명 등이 상황에 따라서 다른 의미로 해석될수 있는것

* 다형성의 구체 사례

  * 부모 타입으로 자식 객체를 참조하여 부모 타입에 대한 메소드들을 쓸수 있음
  * 부모 타입으로 자식 타입의 객체를 참조할 때는 묵시적으로 형변환, 부모 타입의 객체를 자식 타입으로 참조하게 할때는 명시적으로 형변환 할수 있고 그 객체가 원래 자식 객체였는지 부모 객체 였는지에 따라 사용 가능한 필드나 메소드가 정해짐

* 객체지향 설계의 5원칙

  * `SRP(Single Responsibility Principle)` : 단일 책임 원칙, 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단하나의 이유이어야 한다.
  * `OCP(Open-Closed Principle)`:  개방-폐쇄 원칙, 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  * `LSP(Liskov Substitution Principle)`: 인터페이스 분리 원칙, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  * `DIP(Dependency Inversion Principle)` : 의존 역전 원칙, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

* 클래스와 인스턴스의 차이

  * 클래스는 객체를 만들기 위한 템플릿, 객체는 클래스라는 템플릿을 토대로 `메모리에 할당한 실체`

* Immutable

  * 생성 후 변경 불가한 객체로 변경을 하려면 복사 이후 변경해야함

* Call by Value vs Call by Reference

  * Call by Value 와 Call by Reference 는 **값을 복사하여 처리하느냐, 아니면 직접 참조하느냐 차이** `Call by value` 는 인자로 받은 값을 복사하여 처리하고 `Call by reference` 는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 줌

* 컴파일 언어 와 스크립트 언어의 차이

  * `컴파일 언어` 는 컴파일러를 통해 사전에 컴파일 되어 기계어 상태로 실행되고 `스크립트 언어`는 컴파일 단계없이 인터프리터에 의해 실행 단계에서 한줄씩 기계어로 변역하여 실행
  * 일반적으로 컴파일언어가 스크립트 언어에 비해 빠르고 안정적이다
  * 컴파일 언어는 오류 찾기가 쉽고 , 스크립트 언어는 한줄씩 실행되어 오류 찾기가 힘들다

* 동기식과 비동기식의 차이

  * 동기식은 요청에 대한 응답을 기다린후 `응답이 오면 실행` 하는 방식이고 비동기식은 요청에 대한 `응답을 기다리지 않고 실행` 하는 방식
  * 동기식은 구성이 단순하나 멀티태스킹이 불가능하고 비동기식은 멀티태스킹이 가능하나 요청량이 많아질 경우 부하 컨트롤 과 데이터의 일관성 유지등 추가적인 처리가 필요하다

* 블락킹과 논블락킹의 차이

  * 블락킹은 I/O 처리 함수가 끝날 때까지 기다리고 처리가 끝나면 결과를 리턴하는 방식이고 논블락킹은 I/O 처리 함수가 끝나지 않더라도 기다리지 않고 다른 작업을 처리하는 방식

* 블락킹과 비동기의 차이

  * 블락킹과 비동기 모두 응답을 기다리지 않는 공통점이 있지만, 재실행 시점이 비동기는 `요청에 대한 응답` 이라는 관점이고 블락킹은 `I/O처리(시스템 함수 호출의 리턴)` 이라는 관점에서 다르다

* RESTful API

  * `REST` 는 `HTTP, WWW에서 웹에 존재하는 모든 자원에 고유한 URI를 부여해 활용하는것`으로 , 자원을 저으이하고 자원에 대한 주소를 지정하는 방법론
  * `RESTful API` 는 `REST 기반의 규칙들을 지켜서 설계된 API`
  * 기본 설계 원칙
    * `/`를 계층 관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
    * 자원에 대한 정보는 명사로 표현하고 자원에 대한 `행위는 HTTP 메소드`로 표현
    * 소문자와 `-`를 사용
    * 브라우저는 form-data 형식의 submit으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 둘다 form-data 형식으로 보내든 하나로 통일

* RESTful API 장단점

  * HTTP를 사용하므로 웹 인프라를 그대로 이용할수 있고 MSA에 적합하여 재사용에서 이점이 존재
  * HTTP를 사용하므로 HTTP 통신 모델에 제약적

* 디자인 패턴

  * 소프트웨어 코드 작성시에 생기는 `공통적인 문제를 해결하는데 도움이 되는 코드 패턴`

* 디자인 패턴중 싱글톤 패턴

  * 전체 프로그램에서 단 1개의 객체를 생성하고 공유하는 코드 패턴으로 한번의 객체 생성으로 재사용이 가능하기 때문에 메모리 낭비를 방지하고 객체가 전역성을 띄기 때문에 공유가 용이

* 디자인 패턴중 MVC 패턴

  * Model, View, Controller라고 하는 컴포넌트로 분리하여 `비지니스 처리 로직`과 사용자 `인터페이스 요소`를 분리시켜 서로 영향없이 개발하기 수월

* 디자인 패턴중 MVT 패턴

  * MVC 와 동일한 역할을 수행하며 MVC 에서 View를 Template, Controller 를 View 라고 표현 한다.

* 디자인 패턴중 팩터리 패턴

  * 팩토리 패턴은 클래스의 `인스턴스를 만드는 것을 서브클래스에서 결정하는 패턴` 으로 팩토리 메서드 패턴과 추상 팩토리 패턴으로 구체화됨
  * 팩토리 메서드 패턴: 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정
  * 추상 팩토리 패턴: 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성

* PostgresSQL 과 ElasticSearch의 차이점

  * PostgresSQL은 관계형 데이터베이스이고 ElasticSearch 는 검색 및 분석엔진으로 다르고 ES는 데이터 모델을 JSON으로 하고 있어 NoSQL 처러 사용할수 있음

* Redis의 데이터 휘발을 막기 위한 방법

  * `snapshot` 기능을 통해 디스크에 백업하거나 AOF(Append Of File) 기능을 통해 `명령 쿼리를 저장` 해두고 서버가 셧다운 되면 재실행

    > AOF는 명령이 실행될때 마다 기록되는 파일(입력/수정/삭제 명령, 조회명령은 기록되지 않음)
    >
    > RDB 특정 간격마다 메모리에 있는 레디스 데이터 전체를 디스크에 쓴다(특정 시점마다 백업을 받을때 사용)

* TDD

  * `테스트 코드를 작성 한 후 그것을 통과하는 실행 코드를 작성` 하는 cycle로 개발을 해가는 방법으로 디버깅이 쉬워지고 코드의 신뢰성이 높아짐

* DDD

  * 도메인이 중심이 되는 개발 방식, `소프트웨어의 연관된 부분들을 연결하여 계속해서 진화하는 새로운 모델을 만들어나가 복잡한 애플리케이션을 만드는것을 쉽게 해줌`  , **느슨한 결합도, 높은 응집도** 를 가지고 있음

* 크롬 탭은 프로세스인지 스레드인지

  * 크롬은 탭마다 PID를 가지고 있는 Process이며 각 Tab 마다 랜더링 정보나 기타 데이터를 따로 관리, 그로 인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는 장점이 존재

* 함수형 프로그래밍

  * 함수형 프로그래밍은  계산을 수학적 함수의 조합으로 생각하는 방식
  * 1급 객체와 데이터 불변성 그리고 고차함수, 합성함수, 순수함수와 같은 다양한 함수 개념으로 구성

* Git에서 merge 와 rebase의 차이

  * git merge 를 하면 브랜치를 브랜치의 커밋로그는 사라지고 `병합하는 커밋로그가 master에 head에 추가`
  * gir rebase를 하면 브랜치를 base로 master 를 `커밋을 재정렬하여 브랜치의 커밋 하나 하나가 master에 정리되어 추가`

* 클라우드로의 전환이 필수적인 이유

  * 비용이 낮음: 서버 장비를 구매하고 유지하는 비용이 장기적으로 봤을때 클라우드 시스템을 이용하는 비용보다 비쌈
  * 효율적인 인적자원 운영: 직접 방문해야 하는 On-premise에 반해 웹에서 100% 제어 및 모니터링이 가능하기 때문에 개발(혹은 설계) 인력과 공존이 가능
  * 안정성: 클라우드는 다양한 공간으로 분산하기 때문에, 분산된 모든 곳에 동시다발적으로 문제가 생기지 않는 한 장애가 발생하지 않음
  * 확장성 : 트래픽이 임계점에 도달하면 빠르게 서버를 확장할수있음

  > k8s autuscaling 기능을 설정해 두었을 경우 트래픽이 발생하면 clone 웹서버를 생성하여 트래픽을 효율적으로 처리할수 있도록 도와줌, 트래픽이 줄어들면 다시 웹서버 컨테이너를 없애서 디스크 관리또한 가능



# Python

* Generator와 사용시의 장점

  * `Iterator를 생성해주는 루틴`으로 `yield` 키워드를 통해서 만드는데, Generator는 한번에 모든 데이터를 메모리에 적재할 필요가 없어서 메모리 효율이 높고 계산 결과가 필요할때 수행되므로 수행 시간을 꼭 필요한 시간 까지 늦출수 있다

* Decorator와 사용시의 장점

  * 기존의 코드에 여러 가지 기능을 추가하는 파이썬 구문으로 데코레이터를 함수나 클래스로 정의하고 수행하고자 하는 함수에 `@` 키워드를 통해서 삽입하여 실행시켜 생산성을 극대화 할수 있음

  > @login_required 사용자가 로그인한 경우에 아래행 실행

* Python Garbage Collection 동작 방식

  * 각각의 객체마다 `regerence count`를 갖고 있고 몇 곳에서 객체를 참조하는지를 나타내는데 인터프리터가 계속 이를 확인하다가 이 count 가 0이 되는 경우 그 객체를 삭제

* GIL 과 GIL을 보완하는 방법

  * 파이썬은 하나의 스레드만이 인터프리터의 제어권을 가질수 있는 개념인 GIL(Global Interpreter Lock)은 멀티 코어 환경에서도 어느 시점에서나 1개의 스레드만 실행될수 있기 때문에 `threading` 이 아닌`multiprocessing` 모듈을 통해 스레드 단위가 아닌 프로세스 별로 인터프리터 락을 잡아 보완해야 한다.

* Duck Typing

  * 동적 타입을 가지는 프로그래밍 언어에서 많이 사용되는 개념으로, 객체의 실제 타입보다는 객체의 변수와 메소드가 그 객체의 적합성을 결정하는 것을 의미한다.



# Design

* 영화관 좌석 예매 프로그램을 만들려고 한다. 해당 좌석에 대해 어떤 자료구조를 사용할 것인가?
  * 영화관 좌석 예매 시 좌석에 대한 동시적인 접근이 이뤄지므로 동기화 처리가 이뤄진 자료구조를 사용해야한다.
  * 탐색 관점에 있어서는 Array 가 빠르다
* 은행에서 송금을 하는 과정이 3단계로 되어 있는데 3단계에서 오류가 났다. 어떻게 해야 하는다?
  * ACID의 A의 원칙에 따라 전체를 Rollback 해야한다.
* DB관점에서 제한된 리소스로 인해 트래픽의 요청이 많은것에 대해서 어려움을 겪고 있을때 해결할수 있는 방법은 무엇인가?
  * 커넥션 풀을 이용하거나 메모리 캐시 DB를 이용한다.
* 서버 인스턴스를 여러개 돌릴때 어떤 걸 고려해야 되나?
  * 공유 자원에 대한 쓰기가 있을 경우 동기화가 이뤄져야 한다.
* 다수의 서버에서 어떻게 로그를 모니터링 할 것인가?
  * 로그서버를 구축하여 한곳에서 로그를 관리하며 특정 문구에 대한 트리거를 생성한다.