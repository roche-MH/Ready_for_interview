# Network

* HTTP 의 GET 과 POST 비교
* TCP 3,4-way-handshake
* TCP와 UDP 의 비교
  * 유니캐스트
  * 브로드캐스트
  * 멀티캐스트
  * 유니캐스트,브로드캐스트,멀티캐스트 비교
* 흐름제어, 혼잡제어, 오류제어
  * 흐름제어
    * 흐름방법
      * 정지대기
      * 슬라이딩 윈도우
  * 혼잡제어
    * 혼잡제어 종류
      * 합 증가/곱 감소
      * 슬로우 스타트
      * 혼잡회피
      * 빠른 회복
  * 오류제어
    * 오류제어 종류
      * 정지대기 ARQ
      * Go-Back-n ARQ
      * Selective-reject ARQ
* HTTP 와 HTTPS
  * HTTP 의 문제점들
* DNS Round Robin 과 Load Balancer 차이
  * 로드밸런서
  * 라운드 로빈 문제점
  * DNS 라운드 로빈 단점 해소 알고리즘
    * WBR
    * lc
    * wlc
    * sed
* VLAN
* 웹 통신의 흐름



## HTTP 의 GET 과 POST 비교

둘다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할때 사용하는 방식이다.

하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용해야 한다.

**GET**

우선 GET 방식은 요청하는 데이터가 `Http Request Message`의 Header 부분의 url 에 담겨서 전송된다. 때문에 url 상에 `?` 뒤에 데이터가 붙어 request를 보내게 되는것이다. 이러한 방식은 Url 이라는 공간에 담겨가기 때문에 전송할수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 `GET` 방식은 적절하지 않다(ex. password)

**POST**

POST 방식의 request 는 `HTTP Message` 의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 비슷하다)



그렇다면 이러한 특성을 이해한 뒤에는 어디에 적용되는지를 알아봐야 그 차이를 극명하게 이해 할수 있다. 우선 GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 요도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 가지고 있다고 볼수 있다. 반면 POST는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.

부수적인 차이점을 좀더 살펴 보다면 GET 방식의 요청은 브라우저에서 Caching 할수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존 Caching 되었던 데이터가 응답될 가능성이 존재한다.  



## TCP 3-way, 4-way handshake

TCP는 Connection-Oriented(연결 지향)프로토콜이다.

이 말은 프로토콜에 의해 연속적으로 패킷의 상태정보를 확인하고 유지하는 것을 기본으로 한다고 볼수 있다.

따라서 장치간의 데이터를 전송하기전에 `연결`에 관련하여 세션을 수립하는 과정이 중요하다. 

아래 그림**3-way-handshake** 는 tcp의 논리적인 접속을 성립(establish)하는 그림이다.

![image-20200806165956571](https://t1.daumcdn.net/cfile/tistory/99087C405C18E3CD28)

* Client 는 Server 에게 접속 요청 메세지(SYN)를 전송하고 SYN_SENT 상태가 된다.
* Server 는 SYN 요청을 받고 Client에 요청을 수락(SYN + ACK) 하고 SYN_RECEIVED 상태가 된다.
* Client 는 Server 에게 수락 확인(ACK)를 보내고 Server 는 Established 상태가 된다.
* 그리고 실제로 패킷을 뜯어 보면 Flags 에 전달 내용을 볼수 있고 이때 Sequence number, Acknowledgment number 등이 변경 되는것을 알수있다.



**4-way handshake** 는 논리적인 접속 상태를 `해제` 하기 위한 과정이다.

해당 과정을 통해 Server, Client 는 tcp 연결이 해제되면서 연결을 위해 사용했던 리소스 정리가 일어나게 된다.

![image-20200806170727323](https://t1.daumcdn.net/cfile/tistory/99229C485C1D90C038)

* 연결이 되어있는 상태에서
* 연결을 종료하고자 하는 Client 는 Server 에게 TCP Header 의 flags 필드 FIN을 1로 세팅하여 전송하고 소켓을 FIN_WAT_1 상태로 변경하게된다.
* FIN을 받은 Server는 CLOSE_WAIT 상태로 변경하게 되며 FIN에 대응되는 ACK를 전송해준다.
* ACK를 전송받은 Client 는 FIN_WAIT_2 상태로 변경되며 server의 FIN을 기다린다.
* Server 는 연결 종료를 위해 FIN 패킷을 Client 에게 전송하며 소켓을 LAST_ACK 상태로 변경하게 되고
* FIN을 받은 Client 는 TIME_WAIT 상태로 변경되며 FIN에 대응되는 ACK를 server 에 전송한다.
* ACK를 받은 Server 는 소켓을 CLOSED 상태로 변경하고
* 시간이 지난뒤 Client도 소켓을 CLOSED 상태로 변경한다.



## TCP 와 UDP의 비교

**UDP**

`UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)` 비연결형 프로토콜이다. IP 데이터그램을 캡슐화 하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다.

UDP는 `흐름제어, 오류제어` 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다.

이 모두가 사용자 프로세스의 몫이다. UDP 가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.

종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청또는 응답이 손실된다면, 클라이언트는 time out 되고 다시 시도할수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP 처럼 초기설정(initial setup)에서 요구되는 프로토콜보다 적은 메시지가 요구된다.

`UDP`를 사용하는 것들에는 `DNS`가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다



또한 UDP 통신은 비신뢰성 이기때문에 일반적으로 TCP 보다 조금더 빠른 속도를 가지고 있어서 Stream 서버에서 대부분 사용하는 것으로 알고 있다.



**TCP** 

대부분의 인터넷 응용 분야들은 **신뢰성** 과 **순차적인 전달** 을 필요로 한다. UDP 로는 이를 만족시킬수 없으므로 다른 프로토콜이 필요하여 탄생한것이 `TCP`이다.

`TCP(Transmission Control Protocol, 전송제어 프로토콜)`는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 **바이트 스트림을 전송** 하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두 소켓이라고 부르는 종단점을 생성함으로써 이루어 진다. TCP 에서 연결 설정 `3-way handshake` 를 통해 행해진다.

모든 TCP 연결은 전이중(Full-duplex), 점대점(point to point) 방식이다. 전이중이란 전송이 양방향으로 동시에 일어날수 있음을 의미하며 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다. **TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.**



**유니캐스트**

* 유니캐스트는 정보를 전송하기 위한 프레임에 자신의 `MAC` 주소와 목적지의 `MAC` 주소를 첨부하여 전송하는 방식을 말한다. 어떤 시스템이 유니캐스트 방식으로 데이터를 전송하게 되면 같은 네트워크에 있는 모든 시스템들은 그 `MAC` 주소를 받아서 자신의`MAC` 주소와 비교후에 자신의 `MAC` 주소와 같지 않다면 프레임을 버리고 같다면 프레임을 받아서 처리하게 된다. **유니캐스트 방식은 가장 많이 사용하는 방식으로 한개의 목적지 `MAC`주소를 사용하고 CPU 성능에 문제를 주지 않는 방식이다.**

**브로드캐스트**

* 브로드캐스트 방식은 로컬 네트워크에 연결되어 있는 모든 시스템에게 프레임을 보내는 방식을 말한다. 브로드캐스트 방식의 경우 브로드캐스트용 주소가 미리 정해져 있고, 수신 받는 시스템은 이 주소가 오면 패킷을 자신의 `CPU`로 전송하고 `CPU`가 패킷을 처리하는 방식이다. 모든 시스템에게 패킷이 전송되므로 트래픽이 증가하고 `CPU`도 패킷을 처리해야 하므로 성능에 저하가 생긴다. **브로드캐스트 방식은 통신하고자 하는 시스템의 `MAC`주소를 알지 못하는 경우, 네트워크에 있는 모든 시스템에게 알리는 경우, 라우터끼리 정보를 교환하거나 새로운 라우터를 찾는 경우 등에 이용이 된다.**

**멀티캐스트**

* 멀티캐스트는 네트워크에 연결되어 있는 시스템 중 일부에게만 정보를 전송하는 것으로 특정 그룹에 속해 있는 시스템에게만 한번에 정보를 전송할 수 있는 방법을 말한다. 멀티캐스트는 라우터가 **멀티캐스트를 지원해야만 사용 가능하다는 `단점`이 있다.**

**유니캐스트,브로드캐스트,멀티캐스트 비교**

* 유니캐스트 : 1대1(특정단일)
* 브로드캐스트 : 1대 다수(불특정 다수)
* 멀티캐스트 : 1대 다수 (특정 집단)

![image-20200807110541775](https://mblogthumb-phinf.pstatic.net/MjAxODA0MTFfMjEy/MDAxNTIzNDU0Njk5OTg1.-ODTs3RC7n3VHfAOuLrst8sTkk8dDgRBHazV_rr_x_og.d-UdLCTY6TA3cp6-Tsfy_zi_Ojg7d4JXouYQkXjQ2YIg.PNG.wnrjsxo/image.png?type=w800)

## 흐름제어, 혼잡제어, 오류제어

TCP의 가장 큰 특징이며 UDP 와 대조되는 부분은 신뢰성이다. 이러한 신뢰성을 구성해 주는 방법은 흐름제어, 혼잡제어, 오류제어가 있다.



**흐름제어**

> 송신(호스트)<>수신(호스트)

* 흐름제어는 수신측과 송신측의 데이터처리 속도 차이를 해결하기 위한 기법이다.
* 만약 송신측의 전송량 > 수신측의 처리량 일경우, 전송된 패킷은 수신측의 큐를 넘어서 손실될수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다.

**흐름제어 방법**

1. 정지-대기(stop-and-wait)

   * 구조가 간단한 대신, 하나를 주고 응답을 받기 때문에 비효율 적이다.

   ![image-20200807111247063](https://goodgid.github.io/assets/img/network/error_flow_control_1.png)

2.  슬라이딩 윈도우(Sliding Window)

   * 윈도우는 전송,수신 스테이션 양쪽에서 만들어진 버퍼(Buffer)의 크기다. 윈도우의 크기 = (가장 최근 ACK로 응답한 프레임의 수) - (이전에 ACK 프레임을 보낸 프레임의 수)

   * **슬라이딩 윈도우 기법은 앞의 정지-대기 기법의 비효율성을 개선한 기법이다.**

   * ACK프레임을 수신하지 않더라도, 여러개의 프레임을 연속적으로 전송할수 있다.

   * 전송측 윈도우 n-1 개의 프레임을 포함한다.

     ![image-20200807111618381](https://goodgid.github.io/assets/img/network/error_flow_control_2.png)

   * 위와 같은 구조에서 데이터 0,1을 전송했다고 가정하면 슬라이딩 윈도우의 구조는 다음과 같이 변하며 윈도우의 크기는 전송한 데이터 프레임만큼 줄어들게 된다.

   * ![image-20200807111708090](https://goodgid.github.io/assets/img/network/error_flow_control_3.png)

   * 이때 수신측에서 ACK 라는 프레임을 받게 된다면 전송측은 0,1 이 데이터를 정상적으로 받았음을 알게되고, 전송측은 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계를 확장한다.

   * ![image-20200807111814566](https://goodgid.github.io/assets/img/network/error_flow_control_4.png)



**혼잡제어**

> 송신(호스트)<> 라우터(네트워크)

* 혼잡 제어는 송신측과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다.
* 송신된 패킷이 네트워크 상의 라우터가 처리할수 있는 양을 넘어서 혼잡하게 되면 데이터가 손실될 수 있기 때문에 송신측의 전송량을 제어하게 된다.

**혼잡 제어 종류**

1. 합 증가/곱 감소

   * 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 창 크기(단위 시간내에 보내는 패킷의 수)를 1씩 증가시켜가면서 전송하는 방법
   * 만일 **패킷 전송을 실패하거나 일정한 시간을 넘으면** 패킷을 보내는 **속도를 절반으로 줄이게** 된다.
   * 이 방식은 공평한 방식이다.
   * 문제점은 **초기에 네트워크의 `높은 대역폭`을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 `미리 감지하지 못한다.`**
   * 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식

2. 슬로우 스타트

   * **합 증가/곱 감소 방식**이 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 올리는데 **걸리는 시간이 너무 길다**는 단점이 있다.
   * slow start 방식은 합 증가/곱 방식과 마찬가지로 패킷을 하나씩 보내는 것부터 시작하고, 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 Window Size 를 1씩 늘린다. 즉 한 주기가 지나면 Window size 가 2배로 된다.
   * 따라서 전송 속도는 합 증가/곱 감소와는 다르게 지수 함수 꼴로 증가하게 된다.
   * 대신 혼잡 현상이 발생하면 Window size 를 1로 떨어 뜨리게 된다.
   * 처음에는 네트워크의 수용량을 예상할수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느정도 예상할수 있으므로 혼잡 현상이 발생하였던 Window size 의 절반 까지는 이전처럼 **지수 함수 꼴**로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식

   ```text
   1) 초기 혼잡 윈도우 크기 1로 전송 = 전송 호스트는 하나의 패킷만 전송
   2) 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송
   3) 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기 4로 하여 전송
   4) 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기 8로 하여 전송
   ```

   ![image-20200807113722236](https://goodgid.github.io/assets/img/network/error_flow_control_10.png)

   * 전송 되어지는 데이터의 크기가 임계 값에 도달하면 **혼잡 회피 단계**로 넘어간다.

3. 혼잡회피

   * 윈도우의 크기가 임계값에 도달한 이후에 데이터의 손실이 발생할 확률이 높아지게 된다.
   * 데이터를 전송함에 있어서 조심하는 단계
   * 수신 호스트로부터 일정 시간 동안까지 Ack를 수신하지 못하는 경우
     * 타임아웃의 발생 : 네트워크에 혼잡이 발생하였다고 인식
     * 혼잡상태로 인식된 경우
       * 윈도우의 크기를, 즉 세그먼트의 수를 1로 줄임
       * 동시에 임계 값을 패킷 손실이 발생하였을때의 윈도우 크기의 반으로 줄임

4. 빠른회복

   * 빠른 회복 정책은 혼잡한 상태가 되면 Window Size 를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법
   * 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 **합 증가/곱 감소 방식**으로 동작하게 된다.



**오류 제어**

> 오류제어 기법은 `오류검출과 재전송`을 포함한다.

* ARQ기법을 사용하여 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다.
* ARQ기법은 흐름제어 기법과 관련되어 있는데, `정지-대기`는 정지-대기-ARQ로, `슬라이딩 윈도우`는 GBn(Go-Back-n)ARQ 또는 SR(Selective-Reject)ARQ 형태로 구현한다.

**오류 제어 종류**

> ARQ : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식



1. 정지-대기 ARQ

* 전송스테이션은 수신측에서 보내준 ACK를 받을때 까지, 프레임의 복사본을 유지한다.
* 식별을 위해 데이터 프레임과 ACK 프레임은 각각0,1 번호를 부여한다.
* 수신측이 데이터를 받지 못했을 경우, NAK를 보내고, NAK를 받은 송신측은 데이터를 재전송한다.
* 만약 데이터나 ACK가 분실되었을 경우 일정간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다.

![image-20200807114409553](https://goodgid.github.io/assets/img/network/error_flow_control_5.png)

2. Go-Back-n ARQ(GBn ARQ)

* 전송된 프레임이 손상되거나 분실될 경우, 확인된 마지막 프레임 이후로 모두 재전송 하는 기법이다.

* 슬라이딩 윈도우는 연속적인 프레임 전송 기법이므로, 전송 스테이션은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK 와 NAK 모두 각각 구별해야 한다.

* ACK : 다음 프레임을 전송

  NAK : 손상된 프레임 자체 번호를 반환

* 재전송 되는 경우는 다음과 같다

  * NAK 프레임을 받았을 경우
  * 전송 데이터 프레임의 분실
  * 지정된 타임아웃내의 ACK 프레임 분실

* 전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 다시 재전송을 시작한다.

* 수신측은 원하는 프레임이 아닐 경우 모두 폐기 처리한다.

* 타임아웃(ACK의 분실)일 경우, 마지막 ACK 된 데이터부터 재전송한다.



3. Selective-Reject(SR) ARQ

* GBn ARQ의 재전송되는 프레임 이후의 모든 프레임을 재전송하는 단점을 개선한 방법이다.
* SR ARQ는 손상되거나 분실된 프레임만 재전송한다.
* 그렇기 때문에 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼를 필요로 한다.



**GBn ARQ , SR ARQ의 비교**

![image-20200807114843622](https://goodgid.github.io/assets/img/network/error_flow_control_9.png)



## HTTP 와 HTTPS

**HTTP 의 문제점**

* HTTP는 평문 통신이기 때문에 도청이 가능하다.
* 통신 상대를 확인하지 않기 때문에 위장이 가능하다
* 완전성을 증명할수 없기 때문에 변조가 가능하다

위 3가지는 다른 암호화 하지 않은 프로토콜에도 공통되는 문제점이다.

**TCP/IP 는 도청 가능한 네트워크이다**

TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼수 있다. 패킷을 수집하는 것만으로도 도청할수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할수 있기 때문에 암호화 하여 통신해야 한다.

**보안 방법**

1. 통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할수 있다. SSL을 조합한 HTTP를 `HTTPS(HTTP Secure) or HTTP over SSL` 이라고 부른다.
2. 콘텐츠 암호화 말 그대로 HTTP를 사용해서 운반하는 내용인, HTTP 메시지에 포함되는 콘텐츠만 암호화 하는 것이다. 암호화해서 전송하면 받은 측면에서는 그 암호를 해독하여 출력하는 처리가 필요하다



**통신 상대를 확인하지 않기 때문에 위장이 가능하다**

HTTP 에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 리퀘스트를 보낼수 있다. IP 주소나 포트등에서 그 웹서버에 액세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.

1. 리퀘스트를 보낸 곳의 웹서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할수 없다.
2. 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할수 없다
3. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할수 없다
4. 어디에서 누가 리퀘스트 했는지 확인할수 없다
5. 의미 없는 리퀘스트도 수신한다 -> Dos 공격을 방지할수 없다.

**보안 방법**

위 암호화 방법으로 언급된 `SSL`로 상대를 확인할 수 있다. SSL 은 상대를 확인하는 수단으로 **증명서** 를 제공하고 있다. 증명서는 신뢰할 수 있는 **제 3 자 기관에 의해** 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.



**완전성을 증명할수 없기 때문에 변조가 가능하다**

여기서 완전성이란 **정보의 정확성** 을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.

**보완 방법**

`MD5`, `SHA-1` 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 `HTTPS`를 사용해야 한다. SSL 에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.



**HTTPS**

> HTTP에 암호화와 인증, 그리고 완전성 보호를 더한 HTTPS

`HTTPS`는 SSL 의 껍질을 덮어쓴 HTTP 라고 할 수 있다. 즉, HTTPS 는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 `SSL(Secure Socket Layer)` or `TLS(Transport Layer Security)`라는 프로토콜로 대체하는 것 뿐이다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 **SSL 이 TCP 와 통신** 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

HTTPS 의 SSL 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.



**모든 웹페이지에서 HTTPS를 사용하지 않았던 이유**

평문 통신에 비해서 암호화 통신은 CPU 나 메모리 등 리소스가 많이 필요하다. 통신 할때 마다 암호화를 하면 많은 리소스를 소비하기 때문에 서버 한대당 처리할수 있는 리퀘스트의 수가 줄어들게 된다. 그렇기 때문에 민감한 정보를 다룰때만 HTTPS에 의한 암호화 통신을 사용했었다.

하지만 무어의 법칙 처럼 CPU, 메모리등 장비의 성능은 매년 몇배이상의 향상을 기록하고 있으며 2010 년 기준 Google, Facebook, Twitter 엔지니어들은 향상된 CPU와 메모리를 사용하면서 또 LB(Load Balancer) 처리를 하면서 HTTPS 의 성능은 HTTP를 사용할 필요없을정도로 빠른 속도처리가 가능하게 되었다는 것을 알게되었고 HTTP/2 가 적용되면서 많은 사이트들이 HTTPS 를 사용하고 있다.



## DNS Round Robin 과 Load Balancer 차이

**Load Balancer(부하분산기)**는 하나의 IP 주소에 대해 요청을 복수의 서버로 분산할수 있다. DNS **라운드로빈**에서는 웹서버마다 다른 글로벌 주소를 할당할 필요가 있었지만, **로드밸런서**를 이용하면 글로벌 주소를 절약할수 있다. 또한 DNS **라운드로빈**에서는 웹 서버측면에서 연구해서 다중화 구성을 했지만, **로드밸런서**에서는 그럴 필요가 없다.

* 로드밸런서의 동작

  로드밸런서는 서비스용 글로벌 주소를 가진 가상 서버로서 동작한다. 클라이언트로부터 전송되어 온 요청을 실제 웹서버로 중계함으로써 마치 자신이 웹 서버인 것처럼 동작한다.

* 로드밸런서의 기능

  로드밸런서는 여러 대의 리얼서버중 한대를 선택해서 처리를 중계한다. 이때,

  헬스체크가 실패하는 서버는 선택되지 않고 반드시 헬스체크가 성공한 서버를 선택한다. 따라서, 특정 서버 한대가 정지해 있더라도 정상적으로 가동하고 있는 서버가 있는 한 서비스가 정지하지 않는다.

* 로드밸런서의 도입장벽

  로드밸런서 = 고가의 장비라는 이미지나 제대로 운용할수 있을까 걱정과 같은 불안감이 도입장벽이 된다.

  >  OpenSource Software 로 구축해서 스스로 운영할수 있다. ex) HAProxy , IPVS
  >
  > HA 구성 이중화라고 하며, VIP 를 통해서 외부와 통신하는 방식



**DNS Round Robin 방식의 문제점**

1. 서버의 수 만큼 공인 IP 주소가 필요함에 따라 부하 분산을 위해 서버의 대수를 늘리기 위해서는 그 만큼의 공인 IP 가 필요하다
2. 균등하게 분산되지 않음 모바일 사이트 등에서 문제가 될수 있는데, 스마트폰의 접속은 캐리어 게이트웨이 라고 하는 프록시 서벌르 경유한다. 프록시 서버에서는 이름변환 결과가 일정 시간동안 캐싱되므로 같은 프록시 서버를 경유하는 접속은 항상 같은 서버로 접속된다. 또한 PC 용 웹 브라우저도 DNS 질의 결과를 캐싱하기 때문에 균등하게 부하분산이 되지 않는다. DNS 레코드의 TTL 값을 짧게 설정함으로써 어느정도 해소가 되지만, TTL 에 따라 캐시를 해제하는 것은 아니므로 반드시 주의가 필요하다.
3. 서버가 다운되도 확인 불가 DNS 서버는 웹서버의 부하나 접속 수 등의 상황에 따라 질의 결과를 제어할 수 없다. 웹 서버의 부하가 높아서 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황인지를 감지할수 없기 때문에 어떤 원인으로 다운되더라도 이를 검출하지 못하고 유저들에게 제공한다.이때문에 유저들은 간혹 다운된 서버로 연결이 되기도 한다. DNS 라운드 로빈은 어디까지나 부하분산을 위한 방법이지 다중화 방법은 아니므로 다른 S/W 와 조합해서 관리할 필요가 있다.

Round Robin 방식을 기반으로 단점을 해소하는 DNS 스케줄링 알고리즘이 존재한다.

**Weighted round robin (WBR)**

각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다. 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버는 가중치를 높게 설정하는 것이 좋다.

**Least connection**

접속 클라이언트 수가 가장 적은 서버를 선택한다. 로드밸런서에서 실시간으로 connection 수를 관리하거나 각 서버에서 주기적으로 알려주는 것이 필요하다

**wlc(weighted least-connection)**

Least connection 과 같지만 가중치를 가미한다. 구체적으로 (접속수 +1)/ 가중치 가 최소가 되는 서버를 선택하므로 고성능 서버는 가중치를 크게한다.

**sed(shortest expected delay)** 

가장 응답속도가 빠른 서버를 선택하지만 서버에 패킷을 날려 응답시간을 계측하는 것은 아니다 상태가 ESTABLISHED인 접속수(Active 접속수)가 가장적은 서버를 선택하는 것이다. wlc와 거의 동일하게 동작하지만 wlc 에서는 ESTABLISHED 이외의 상태(TIME_WAIT 나 FIN_WAIT 등)인 접속수를 더한다.



## VLAN

VLAN 이란 Virtual Local Area Network 의 약자로 물리적 배치와 상관없이 논리적으로 LAN을 구성할수 있는 기술이다.

**VLAN 장점**

* 네트워크 리소스 보안을 높인다.
  * 네트워크 그룹 설정을 변경하거나 이동하게 되면 보안상의 문제가 발생할 우려가 있지만 VLAN을 이용하면 실직적인 네트워크 그룹의 이동없어도 되어 보안상의 문제를 쉽게 줄일수 있다.
* 비용을 절감할수있다.
  * VLAN 기술을 쓰지 않는다면 서로 차단된 LAN 환경을 구축할때 장비가 추가로 필요하게 된다. 하지만 VLAN을 이용한다면 장비의 추가 없이 차단된 LAN 환경을 구축할 수 있다.
* 관리자의 네트워크 설정작업에 용이하다.
  * 네트워크 관리자가 특정 장비의 네트워크 그룹을 옮겨야 할 때 실 장비를 옮기는 과정없이 스위치 설정만으로 네트워크 그룹을 옮길수 있으므로 편하다.
* 불필요한 트래픽을 줄인다.
  * VLAN은 서로 다른 네트워크 그룹이기 때문에 브로드케스트 패킷이 다른 VLAN으로 전송되지 않는다. 세분화하여 Broadcat domain 을 나눌수 있기 때문에 불필요한 트래픽을 현격히 줄일수 있다.



## 웹통신의 큰 흐름 (Client side)

**in 브라우저**

1. url 에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.
2. 조사된 의미에 따라 HTTP Request 메시지를 만든다.
3. 만들어진 메시지를 웹서버로 전송한다.

이때 만들어진 메시지 전송은 브라우저가 직접하는 것이 아니다. 브라우저는 메시지를 네트워크에 송출하는 기능이 없으므로 OS 에 의뢰하여 메시지를 전달한다. 우리가 택배를 보낼때 직접 보내는게 아니라, 이미 서비스가 이루어지고 있는 택배 시스템을 이용하여 보내는것과 같은 이치 , OS에 송신을 의뢰할 때는 도메인명이 아니라 ip주소로 메시지를 받을 상대를 지정해야 하는데, 이 과정에서 DNS서버를 조회해야 한다.



**in 프로토콜 스택, LAN 어댑터**

1. 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로 부터 메시지를 받는다.
2. 브라우저로 부터 받은 메시지를 패킷 속에서 저장한다.
3. 그리고 수신처 주소 등의 제어정보를 덧붙인다.
4. 그런 다음, 패킷을 LAN 어댑터에 넘긴다.
5. LAN 어댑터는 패킷을 전기나 빛의 신호로 변환시킨다.
6. 신호를 LAN 케이블에 송출시킨다.

프로토콜 스택은 통신중 오류가 발생했을 때, 이 제어 정보를 사용하여 고쳐 보내거나, 각 종 상황을 조절하는 등 다양한 역할을 하게 된다. 네트워크 세계에서는 비서가 있어서 우리가 비서에게 물건만 건네주면, 받는 사람의 주소와 각종 유의사항을 써준다. 여기서는 프로토콜 스택이 비서의 역할을 한다고 볼수 있다.



**in 허브, 스위치, 라우터**

1. LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.
2. 라우터는 패킷을 프로바이더(통신사)에게 전달한다.
3. 인터넷으로 들어가게 된다.



**in 액세스 회선, 프로바이더**

1. 패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반된다.
2. POP를 거쳐 인터넷의 핵심부로 들어가게 된다.
3. 수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러가게 된다.



**in 방화벽, 캐시서버**

1. 패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.
2. 기다리고 있던 방화벽이 도착한 패킷을 검사한다.
3. 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시서버가 존재한다.

굳이 서버까지 가지 않아도 되는 경우를 골라낸다. 액세스한 페이지의 데이터가 캐시서버에 있으면 웹 서버에 의뢰하지 않고 바로 그 값을 읽을 수 있다. 페이지의 데이터중에 다시 이용할수 있는 것이 있으면 캐시 서버에 저장된다.



**in 웹서버**

1. 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다.
2. 메시지를 받은 웹서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.
3. 왔던 방식대로 응답 메시지가 클라이언트에게 전달된다.





